{"content": "package has_close_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Check if in given list of numbers, are any two numbers closer to each other than\n// given threshold.\n// >>> has_close_elements([]float64{1.0, 2.0, 3.0}, 0.5)\n// false\n// >>> has_close_elements([]float64{1.0, 2.8, 3.0, 4.0, 5.0, 2.0}, 0.3)\n// true\nfunc has_close_elements(numbers []float64, threshold float64) bool {\n", "id": 0, "labels": "{\"doctests\":\"transform\", \"original\":\"/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_0_has_close_elements.py\", \"prompt_terminology\":\"reworded\", \"stop_tokens\":[\"\\nfunc\", \"struct\", \"\\n// \"], \"task_id\":\"HumanEval_0_has_close_elements\"}", "test": "func TestHas_Close_Elements(t *testing.T) {\n  candidate := has_close_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}, 0.3), expected: true },\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}, 0.05), expected: false },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}, 0.95), expected: true },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}, 0.8), expected: false },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}, 0.1), expected: true },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}, 1.0), expected: true },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}, 0.5), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "__internal_uuid__": "14d8037e-3435-4e07-ac39-91bfe7e52632"}
{"content": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n", "id": 1, "labels": "{\"doctests\":\"transform\", \"original\":\"/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_1_separate_paren_groups.py\", \"prompt_terminology\":\"reworded\", \"stop_tokens\":[\"\\nfunc\", \"struct\", \"\\n// \"], \"task_id\":\"HumanEval_1_separate_paren_groups\"}", "test": "func TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "__internal_uuid__": "d45d9abf-4d5c-4137-bf58-8ba8156c3191"}
{"content": "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive floating point number, it can be decomposed into\n// and integer part (largest integer smaller than given number) and decimals\n// (leftover part always smaller than 1).\n// Return the decimal part of the number.\n// >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64 {\n", "id": 2, "labels": "{\"doctests\":\"transform\", \"original\":\"/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_2_truncate_number.py\", \"prompt_terminology\":\"reworded\", \"stop_tokens\":[\"\\nfunc\", \"struct\", \"\\n// \"], \"task_id\":\"HumanEval_2_truncate_number\"}", "test": "func TestTruncate_Number(t *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "__internal_uuid__": "1b9c2fcf-be7a-4378-b386-258df5db0b9e"}
{"content": "package below_zero_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're given a list of deposit and withdrawal operations on a bank account that starts with\n// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n// at that point function should return true. Otherwise it should return false.\n// >>> below_zero([]int{1, 2, 3})\n// false\n// >>> below_zero([]int{1, 2, -4, 5})\n// true\nfunc below_zero(operations []int) bool {\n", "id": 3, "labels": "{\"doctests\":\"transform\", \"original\":\"/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_3_below_zero.py\", \"prompt_terminology\":\"reworded\", \"stop_tokens\":[\"\\nfunc\", \"struct\", \"\\n// \"], \"task_id\":\"HumanEval_3_below_zero\"}", "test": "func TestBelow_Zero(t *testing.T) {\n  candidate := below_zero\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: false },\n     { actual: candidate([]int{1, 2, -3, 1, 2, -3}), expected: false },\n     { actual: candidate([]int{1, 2, -4, 5, 6}), expected: true },\n     { actual: candidate([]int{1, -1, 2, -2, 5, -5, 4, -4}), expected: false },\n     { actual: candidate([]int{1, -1, 2, -2, 5, -5, 4, -5}), expected: true },\n     { actual: candidate([]int{1, -2, 2, -2, 5, -5, 4, -4}), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "__internal_uuid__": "356cec7f-3809-4655-8446-b578f07f6cb2"}
{"content": "package mean_absolute_deviation_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// For a given list of input numbers, calculate Mean Absolute Deviation\n// around the mean of this dataset.\n// Mean Absolute Deviation is the average absolute difference between each\n// element and a centerpoint (mean in this case):\n// MAD = average | x - x_mean |\n// >>> mean_absolute_deviation([]float64{1.0, 2.0, 3.0, 4.0})\n// 1.0\nfunc mean_absolute_deviation(numbers []float64) float64 {\n", "id": 4, "labels": "{\"doctests\":\"transform\", \"original\":\"/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_4_mean_absolute_deviation.py\", \"prompt_terminology\":\"reworded\", \"stop_tokens\":[\"\\nfunc\", \"struct\", \"\\n// \"], \"task_id\":\"HumanEval_4_mean_absolute_deviation\"}", "test": "func TestMean_Absolute_Deviation(t *testing.T) {\n  candidate := mean_absolute_deviation\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0}), expected: 0.5 },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0}), expected: 1.0 },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0}), expected: 1.2 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "__internal_uuid__": "d40d61b6-12e1-4281-a0e4-717584ce564e"}
{"content": "package intersperse_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Insert a number 'delimeter' between every two consecutive elements of input list `numbers'\n// >>> intersperse([]int{}, 4)\n// []int{}\n// >>> intersperse([]int{1, 2, 3}, 4)\n// []int{1, 4, 2, 4, 3}\nfunc intersperse(numbers []int, delimeter int) []int {\n", "id": 5, "labels": "{\"doctests\":\"transform\", \"original\":\"/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_5_intersperse.py\", \"prompt_terminology\":\"reworded\", \"stop_tokens\":[\"\\nfunc\", \"struct\", \"\\n// \"], \"task_id\":\"HumanEval_5_intersperse\"}", "test": "func TestIntersperse(t *testing.T) {\n  candidate := intersperse\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}, 7), expected: []int{} },\n     { actual: candidate([]int{5, 6, 3, 2}, 8), expected: []int{5, 8, 6, 8, 3, 8, 2} },\n     { actual: candidate([]int{2, 2, 2}, 2), expected: []int{2, 2, 2, 2, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "__internal_uuid__": "2eb72a64-17b2-4ceb-93dd-e90812025723"}
{"content": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n", "id": 6, "labels": "{\"doctests\":\"transform\", \"original\":\"/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_6_parse_nested_parens.py\", \"prompt_terminology\":\"reworded\", \"stop_tokens\":[\"\\nfunc\", \"struct\", \"\\n// \"], \"task_id\":\"HumanEval_6_parse_nested_parens\"}", "test": "func TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "__internal_uuid__": "aef783e5-c0b4-44b5-a8bb-fbd0a4abb5ed"}
{"content": "package filter_by_substring_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Filter an input list of strings only for ones that contain given substring\n// >>> filter_by_substring([]string{}, \"a\")\n// []string{}\n// >>> filter_by_substring([]string{\"abc\", \"bacd\", \"cde\", \"array\"}, \"a\")\n// []string{\"abc\", \"bacd\", \"array\"}\nfunc filter_by_substring(strings []string, substring string) []string {\n", "id": 7, "labels": "{\"doctests\":\"transform\", \"original\":\"/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_7_filter_by_substring.py\", \"prompt_terminology\":\"reworded\", \"stop_tokens\":[\"\\nfunc\", \"struct\", \"\\n// \"], \"task_id\":\"HumanEval_7_filter_by_substring\"}", "test": "func TestFilter_By_Substring(t *testing.T) {\n  candidate := filter_by_substring\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{}, \"john\"), expected: []string{} },\n     { actual: candidate([]string{\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"}, \"xxx\"), expected: []string{\"xxx\", \"xxxAAA\", \"xxx\"} },\n     { actual: candidate([]string{\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"}, \"xx\"), expected: []string{\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"} },\n     { actual: candidate([]string{\"grunt\", \"trumpet\", \"prune\", \"gruesome\"}, \"run\"), expected: []string{\"grunt\", \"prune\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "__internal_uuid__": "e9c64596-1607-466e-9467-7c89b7fc2180"}
{"content": "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// For a given list of integers, return a list consisting of a sum and a product of all the integers in a list.\n// Empty sum should be equal to 0 and empty product should be equal to 1.\n// >>> sum_product([]int{})\n// []interface{}{0, 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers []int) []interface{} {\n", "id": 8, "labels": "{\"doctests\":\"transform\", \"original\":\"/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_8_sum_product.py\", \"prompt_terminology\":\"reworded\", \"stop_tokens\":[\"\\nfunc\", \"struct\", \"\\n// \"], \"task_id\":\"HumanEval_8_sum_product\"}", "test": "func TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15, 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "__internal_uuid__": "c60a919f-372b-4a14-8b3d-16401110cb12"}
{"content": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n", "id": 9, "labels": "{\"doctests\":\"transform\", \"original\":\"/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_9_rolling_max.py\", \"prompt_terminology\":\"reworded\", \"stop_tokens\":[\"\\nfunc\", \"struct\", \"\\n// \"], \"task_id\":\"HumanEval_9_rolling_max\"}", "test": "func TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "__internal_uuid__": "3276a06f-efe5-4c36-8d56-99abddae4007"}
{"content": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n", "id": 10, "labels": "{\"doctests\":\"transform\", \"original\":\"/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_10_make_palindrome.py\", \"prompt_terminology\":\"reworded\", \"stop_tokens\":[\"\\nfunc\", \"struct\", \"\\n// \"], \"task_id\":\"HumanEval_10_make_palindrome\"}", "test": "func TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "__internal_uuid__": "12e8cbcf-9ad3-4aef-888e-031f4ecb33a0"}
{"content": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n", "id": 11, "labels": "{\"doctests\":\"transform\", \"original\":\"/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_11_string_xor.py\", \"prompt_terminology\":\"reworded\", \"stop_tokens\":[\"\\nfunc\", \"struct\", \"\\n// \"], \"task_id\":\"HumanEval_11_string_xor\"}", "test": "func TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "__internal_uuid__": "a68c852a-6663-4d6e-8bb1-6bcd780e4a72"}
{"content": "package greatest_common_divisor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return a greatest common divisor of two integers a and b\n// >>> greatest_common_divisor(3, 5)\n// 1\n// >>> greatest_common_divisor(25, 15)\n// 5\nfunc greatest_common_divisor(a int, b int) int {\n", "id": 13, "labels": "{\"doctests\":\"transform\", \"original\":\"/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_13_greatest_common_divisor.py\", \"prompt_terminology\":\"reworded\", \"stop_tokens\":[\"\\nfunc\", \"struct\", \"\\n// \"], \"task_id\":\"HumanEval_13_greatest_common_divisor\"}", "test": "func TestGreatest_Common_Divisor(t *testing.T) {\n  candidate := greatest_common_divisor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 7), expected: 1 },\n     { actual: candidate(10, 15), expected: 5 },\n     { actual: candidate(49, 14), expected: 7 },\n     { actual: candidate(144, 60), expected: 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "__internal_uuid__": "4910e539-b863-4f24-8ccd-1bca6f1f4577"}
{"content": "package all_prefixes_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes(\"abc\")\n// []string{\"a\", \"ab\", \"abc\"}\nfunc all_prefixes(myString string) []string {\n", "id": 14, "labels": "{\"doctests\":\"transform\", \"original\":\"/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_14_all_prefixes.py\", \"prompt_terminology\":\"reworded\", \"stop_tokens\":[\"\\nfunc\", \"struct\", \"\\n// \"], \"task_id\":\"HumanEval_14_all_prefixes\"}", "test": "func TestAll_Prefixes(t *testing.T) {\n  candidate := all_prefixes\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []string{} },\n     { actual: candidate(\"asdfgh\"), expected: []string{\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"} },\n     { actual: candidate(\"WWW\"), expected: []string{\"W\", \"WW\", \"WWW\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "__internal_uuid__": "d64d6142-b4da-46f1-8375-2d6751eaf47b"}
{"content": "package string_sequence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n// >>> string_sequence(0)\n// \"0\"\n// >>> string_sequence(5)\n// \"0 1 2 3 4 5\"\nfunc string_sequence(n int) string {\n", "id": 15, "labels": "{\"doctests\":\"transform\", \"original\":\"/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_15_string_sequence.py\", \"prompt_terminology\":\"reworded\", \"stop_tokens\":[\"\\nfunc\", \"struct\", \"\\n// \"], \"task_id\":\"HumanEval_15_string_sequence\"}", "test": "func TestString_Sequence(t *testing.T) {\n  candidate := string_sequence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"0\" },\n     { actual: candidate(3), expected: \"0 1 2 3\" },\n     { actual: candidate(10), expected: \"0 1 2 3 4 5 6 7 8 9 10\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "__internal_uuid__": "1b232d42-34ed-4c90-add8-55a3c8c1e9e6"}
{"content": "package count_distinct_characters_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string, find out how many distinct characters (regardless of case) does it consist of\n// >>> count_distinct_characters(\"xyzXYZ\")\n// 3\n// >>> count_distinct_characters(\"Jerry\")\n// 4\nfunc count_distinct_characters(myString string) int {\n", "id": 16, "labels": "{\"doctests\":\"transform\", \"original\":\"/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_16_count_distinct_characters.py\", \"prompt_terminology\":\"reworded\", \"stop_tokens\":[\"\\nfunc\", \"struct\", \"\\n// \"], \"task_id\":\"HumanEval_16_count_distinct_characters\"}", "test": "func TestCount_Distinct_Characters(t *testing.T) {\n  candidate := count_distinct_characters\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: 0 },\n     { actual: candidate(\"abcde\"), expected: 5 },\n     { actual: candidate(\"abcdecadeCADE\"), expected: 5 },\n     { actual: candidate(\"aaaaAAAAaaaa\"), expected: 1 },\n     { actual: candidate(\"Jerry jERRY JeRRRY\"), expected: 5 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "__internal_uuid__": "084822a0-499f-44a0-afc1-3b942706708d"}
{"content": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n", "id": 17, "labels": "{\"doctests\":\"transform\", \"original\":\"/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_17_parse_music.py\", \"prompt_terminology\":\"reworded\", \"stop_tokens\":[\"\\nfunc\", \"struct\", \"\\n// \"], \"task_id\":\"HumanEval_17_parse_music\"}", "test": "func TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "__internal_uuid__": "772a2a44-ec74-4c5c-98b0-a3a053f14d80"}
{"content": "package how_many_times_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find how many times a given substring can be found in the original string. Count overlaping cases.\n// >>> how_many_times(\"\", \"a\")\n// 0\n// >>> how_many_times(\"aaa\", \"a\")\n// 3\n// >>> how_many_times(\"aaaa\", \"aa\")\n// 3\nfunc how_many_times(myString string, substring string) int {\n", "id": 18, "labels": "{\"doctests\":\"transform\", \"original\":\"/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_18_how_many_times.py\", \"prompt_terminology\":\"reworded\", \"stop_tokens\":[\"\\nfunc\", \"struct\", \"\\n// \"], \"task_id\":\"HumanEval_18_how_many_times\"}", "test": "func TestHow_Many_Times(t *testing.T) {\n  candidate := how_many_times\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\", \"x\"), expected: 0 },\n     { actual: candidate(\"xyxyxyx\", \"x\"), expected: 4 },\n     { actual: candidate(\"cacacacac\", \"cac\"), expected: 4 },\n     { actual: candidate(\"john doe\", \"john\"), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "__internal_uuid__": "6de26f4b-6c13-4ec9-82b4-96e3b067cca5"}
{"content": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n", "id": 19, "labels": "{\"doctests\":\"transform\", \"original\":\"/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_19_sort_numbers.py\", \"prompt_terminology\":\"reworded\", \"stop_tokens\":[\"\\nfunc\", \"struct\", \"\\n// \"], \"task_id\":\"HumanEval_19_sort_numbers\"}", "test": "func TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "__internal_uuid__": "1ba639d9-5693-4307-9e29-e5c352d70fc0"}
{"content": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n", "id": 20, "labels": "{\"doctests\":\"transform\", \"original\":\"/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_20_find_closest_elements.py\", \"prompt_terminology\":\"reworded\", \"stop_tokens\":[\"\\nfunc\", \"struct\", \"\\n// \"], \"task_id\":\"HumanEval_20_find_closest_elements\"}", "test": "func TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "__internal_uuid__": "c652ad94-6416-4aa2-a62e-e81f9163c727"}